/**
 * EntityService.js - Servizio per gestire le operazioni CRUD delle entit√†
 * 
 * Responsabilit√†:
 * - Gestire le operazioni CRUD per le entit√†
 * - Fornire interfaccia unificata per API MVP e evolute
 * - Cache delle entit√† per performance
 * - Preparazione per integrazione con EntityEngine evoluto
 */

class EntityService {
    constructor() {
        this.entityCache = new Map();
        this.entitiesListCache = new Map(); // ‚ú® Cache per liste di entit√† per tipo
        this.cacheTimeout = 30000; // 30 secondi
        this.pendingRequests = new Map(); // Per evitare richieste duplicate
    }

    /**
     * Ottiene una singola entit√† per ID
     * @param {string} entityId - ID dell'entit√†
     * @param {Object} options - Opzioni (includeReferences, forceRefresh)
     * @returns {Promise<Object>} - Entit√† recuperata
     */
    async getEntity(entityId, options = {}) {
        try {
            const cacheKey = `entity_${entityId}`;
            
            // Controlla cache se non forzato refresh
            if (!options.forceRefresh && this.entityCache.has(cacheKey)) {
                const cached = this.entityCache.get(cacheKey);
                if (Date.now() - cached.timestamp < this.cacheTimeout) {
                    console.log(`üîÑ [EntityService] Cache hit per entit√† ${entityId}`);
                    return cached.data;
                }
            }

            // Evita richieste duplicate
            if (this.pendingRequests.has(entityId)) {
                console.log(`‚è≥ [EntityService] Attesa richiesta in corso per ${entityId}`);
                return await this.pendingRequests.get(entityId);
            }

            console.log(`üì• [EntityService] Caricamento entit√† ${entityId}...`);

            const requestPromise = this.performGetEntity(entityId, options);
            this.pendingRequests.set(entityId, requestPromise);

            try {
                const entity = await requestPromise;
                this.cacheEntity(cacheKey, entity);
                console.log(`‚úÖ [EntityService] Entit√† ${entityId} caricata`);
                return entity;
            } finally {
                this.pendingRequests.delete(entityId);
            }

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore recupero entit√† ${entityId}:`, error);
            throw error;
        }
    }

    /**
     * Esegue la richiesta GET per una singola entit√†
     * @param {string} entityId - ID dell'entit√†
     * @param {Object} options - Opzioni
     * @returns {Promise<Object>} - Entit√† recuperata
     */
    async performGetEntity(entityId, options) {
        // Prima prova API evoluta (se disponibili opzioni avanzate)
        if (options.includeReferences !== undefined) {
            try {
                const params = new URLSearchParams();
                if (options.includeReferences) {
                    params.append('includeReferences', 'true');
                }

                const response = await fetch(`/api/entity/${entityId}?${params}`);
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        return result.data;
                    }
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è [EntityService] API evoluta fallita per ${entityId}:`, error.message);
            }
        }

        // Fallback API MVP
        const response = await fetch(`/api/entity/${entityId}`);
        
        if (!response.ok) {
            throw new Error(`Entit√† non trovata: ${entityId} (Status: ${response.status})`);
        }

        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Errore nel recupero entit√†');
        }

        return result.data;
    }

    /**
     * ‚ú® NUOVO: Esegue effettivamente la richiesta per ottenere entit√† per tipo
     * @param {string} entityType - Tipo di entit√†
     * @returns {Promise<Array>} - Lista delle entit√†
     */
    async performGetEntities(entityType) {
        const url = `/api/entities/${entityType}`;
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`Errore nel caricamento entit√† tipo ${entityType} (Status: ${response.status})`);
        }

        const result = await response.json();
        
        if (!result.success) {
            throw new Error(result.error || 'Errore nel recupero entit√†');
        }

        return result.data || [];
    }

    /**
     * Ottiene tutte le entit√† di un tipo specifico - OTTIMIZZATO
     * @param {string} entityType - Tipo di entit√†
     * @param {boolean} forceRefresh - Forzare refresh della cache
     * @returns {Promise<Array>} - Lista delle entit√†
     */
    async getEntities(entityType, forceRefresh = false) {
        try {
            const cacheKey = `entities_${entityType}`;
            
            // ‚ú® Controlla cache per liste entit√†
            if (!forceRefresh && this.entitiesListCache.has(cacheKey)) {
                const cached = this.entitiesListCache.get(cacheKey);
                if (Date.now() - cached.timestamp < this.cacheTimeout) {
                    console.log(`üîÑ [EntityService] Cache hit per entit√† tipo ${entityType} (${cached.data.length} entit√†)`);
                    return cached.data;
                }
            }

            // ‚ú® Evita richieste duplicate per stesso tipo
            const pendingKey = `entities_${entityType}`;
            if (this.pendingRequests.has(pendingKey)) {
                console.log(`‚è≥ [EntityService] Attesa richiesta in corso per tipo ${entityType}`);
                return await this.pendingRequests.get(pendingKey);
            }

            console.log(`üì• [EntityService] Caricamento entit√† tipo ${entityType}...`);

            const requestPromise = this.performGetEntities(entityType);
            this.pendingRequests.set(pendingKey, requestPromise);

            try {
                const entities = await requestPromise;
                // ‚ú® Cache il risultato
                this.entitiesListCache.set(cacheKey, {
                    data: entities,
                    timestamp: Date.now()
                });
                
                // ‚ú® Cache anche le singole entit√†
                entities.forEach(entity => {
                    this.cacheEntity(`entity_${entity.id}`, entity);
                });
                
                console.log(`‚úÖ [EntityService] ${entities.length} entit√† tipo ${entityType} caricate e cachate`);
                return entities;
            } finally {
                this.pendingRequests.delete(pendingKey);
            }

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore recupero entit√† tipo ${entityType}:`, error);
            throw error;
        }
    }

    /**
     * Crea una nuova entit√†
     * @param {string} entityType - Tipo di entit√†
     * @param {Object} data - Dati dell'entit√†
     * @returns {Promise<Object>} - Entit√† creata
     */
    async createEntity(entityType, data) {
        try {
            console.log(`üìù [EntityService] Creazione entit√† tipo ${entityType}...`);
            console.log(`üîç [EntityService] DEBUG: Dati ricevuti:`, data);

            const requestBody = {
                entityType: entityType,
                ...data
            };
            
            console.log(`üîç [EntityService] DEBUG: Request body completo:`, requestBody);
            console.log(`üîç [EntityService] DEBUG: Request body stringificato:`, JSON.stringify(requestBody));

            const response = await fetch('/api/entities', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            console.log(`üîç [EntityService] DEBUG: Response status:`, response.status);

            if (!response.ok) {
                const errorText = await response.text();
                console.log(`üîç [EntityService] DEBUG: Error response:`, errorText);
                throw new Error(`Errore nella creazione entit√† (Status: ${response.status})`);
            }

            const result = await response.json();
            
            if (!result.success) {
                throw new Error(result.error || 'Errore nella creazione entit√†');
            }

            const newEntity = result.data;
            
            // Cache la nuova entit√†
            if (newEntity.id) {
                const cacheKey = `entity_${newEntity.id}`;
                this.cacheEntity(cacheKey, newEntity);
            }

            console.log(`‚úÖ [EntityService] Entit√† creata con ID: ${newEntity.id}`);
            return newEntity;

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore creazione entit√† tipo ${entityType}:`, error);
            throw error;
        }
    }

    /**
     * Aggiorna un attributo di un'entit√†
     * @param {string} entityId - ID dell'entit√†
     * @param {string} attributeName - Nome dell'attributo
     * @param {*} value - Nuovo valore
     * @returns {Promise<Object>} - Risultato dell'aggiornamento
     */
    async updateEntityAttribute(entityId, attributeName, value) {
        try {
            console.log(`üìù [EntityService] Aggiornamento ${attributeName} per entit√† ${entityId}...`);

            const response = await fetch(`/api/entity/${entityId}/attribute`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    attributeName: attributeName,
                    value: value
                })
            });

            if (!response.ok) {
                throw new Error(`Errore nell'aggiornamento attributo (Status: ${response.status})`);
            }

            const result = await response.json();
            
            if (!result.success) {
                throw new Error(result.error || 'Errore nell\'aggiornamento attributo');
            }

            // Invalida cache per l'entit√†
            this.invalidateEntityCache(entityId);

            console.log(`‚úÖ [EntityService] Attributo ${attributeName} aggiornato per ${entityId}`);
            return result;

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore aggiornamento attributo ${attributeName}:`, error);
            throw error;
        }
    }

    /**
     * Elimina un'entit√†
     * @param {string} entityId - ID dell'entit√† da eliminare
     * @returns {Promise<Object>} - Risultato dell'eliminazione
     */
    async deleteEntity(entityId) {
        try {
            console.log(`üóëÔ∏è [EntityService] Eliminazione entit√† ${entityId}...`);

            const response = await fetch(`/api/entity/${entityId}`, {
                method: 'DELETE'
            });

            if (!response.ok) {
                throw new Error(`Errore nell'eliminazione entit√† (Status: ${response.status})`);
            }

            // Rimuovi da cache
            this.invalidateEntityCache(entityId);

            console.log(`‚úÖ [EntityService] Entit√† ${entityId} eliminata`);
            return result;

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore eliminazione entit√† ${entityId}:`, error);
            throw error;
        }
    }

    /**
     * Risolve i reference di un'entit√† (API evoluta)
     * @param {string} entityId - ID dell'entit√†
     * @param {Array} attributeNames - Nomi degli attributi reference da risolvere
     * @returns {Promise<Object>} - Reference risolte
     */
    async resolveEntityReferences(entityId, attributeNames = []) {
        try {
            console.log(`üîó [EntityService] Risoluzione reference per entit√† ${entityId}...`);

            const params = new URLSearchParams();
            if (attributeNames.length > 0) {
                params.append('attributes', attributeNames.join(','));
            }

            const response = await fetch(`/api/entity/${entityId}/references?${params}`);
            
            if (!response.ok) {
                throw new Error(`Errore nella risoluzione reference (Status: ${response.status})`);
            }

            const result = await response.json();
            
            if (!result.success) {
                throw new Error(result.error || 'Errore nella risoluzione reference');
            }

            console.log(`‚úÖ [EntityService] Reference risolte per ${entityId}`);
            return result.data;

        } catch (error) {
            console.error(`‚ùå [EntityService] Errore risoluzione reference per ${entityId}:`, error);
            throw error;
        }
    }

    /**
     * Cache un'entit√†
     * @param {string} cacheKey - Chiave cache
     * @param {Object} entity - Entit√† da cachare
     */
    cacheEntity(cacheKey, entity) {
        this.entityCache.set(cacheKey, {
            data: entity,
            timestamp: Date.now()
        });
    }

    /**
     * Invalida la cache per una singola entit√†
     * @param {string} entityId - ID dell'entit√†
     */
    invalidateEntityCache(entityId) {
        const cacheKey = `entity_${entityId}`;
        this.entityCache.delete(cacheKey);
        console.log(`üßπ [EntityService] Cache invalidata per entit√† ${entityId}`);
    }

    /**
     * Pulisce la cache per un tipo specifico
     */
    clearTypeCache(entityType) {
        const cacheKey = `entities_${entityType}`;
        this.entitiesListCache.delete(cacheKey);
        console.log(`üóëÔ∏è [EntityService] Cache pulita per tipo ${entityType}`);
    }

    /**
     * Pulisce tutta la cache
     */
    clearAllCache() {
        this.entityCache.clear();
        this.entitiesListCache.clear();
        this.pendingRequests.clear();
        console.log('üóëÔ∏è [EntityService] Tutta la cache pulita');
    }

    /**
     * Ottiene statistiche del servizio
     * @returns {Object} - Statistiche del servizio
     */
    getStats() {
        return {
            cacheSize: this.entityCache.size,
            pendingRequests: this.pendingRequests.size,
            cacheTimeout: this.cacheTimeout
        };
    }
}

// Istanza singleton globale
window.EntityService = new EntityService();

console.log('‚úÖ [EntityService] Servizio registrato globalmente'); 